package info.kgeorgiy.ja.sinitsyn.implementor;

import info.kgeorgiy.java.advanced.implementor.Impler;
import info.kgeorgiy.java.advanced.implementor.ImplerException;
import info.kgeorgiy.java.advanced.implementor.JarImpler;

import javax.annotation.processing.Generated;
import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.net.URISyntaxException;
import java.nio.charset.Charset;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.function.UnaryOperator;
import java.util.jar.Attributes;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;

import static info.kgeorgiy.ja.sinitsyn.implementor.Implementor.DefaultValues.*;

/**
 * A tool to generate empty-classes that would inherit the given one.
 *
 * <p>
 *     This tool generates generic-supported classes without unchecked warnings.
 * </p>
 *
 * <p>
 *     Has two available methods {@link #implement(Class, Path)} and {@link #implementJar(Class, Path)}
 *     and three fields: {@link #PROJECT_NAME}, {@link #IMPLEMENTATION_SUFFIX} and {@link #date}
 *     (the last one is only instance-accessible),
 *     that could be touched outside. Also could be run as self-sufficient code with method
 *     {@link #main(String[])}.
 * </p>
 *
 * @author AlexSin
 */
public class Implementor implements Impler, JarImpler {

    /**
     * The name of the implementor that generates classes. Will be written before all methods as
     * {@code @Generated(value = PROJECT_NAME)}
     *
     * @see Generated
     */
    public static final String PROJECT_NAME = "Sinitsyn.implementor";

    /**
     * Suffix that will be added to generated class's name
     */
    public static final String IMPLEMENTATION_SUFFIX = "Impl";

    /**
     * The date when the concrete method was generated. Will be written just like {@link #PROJECT_NAME}
     * before all executables in generated class {@code @Generated(date = date)}
     *
     * @see Executable
     */
    public final String date = new Date().toString();

    /**
     * Map: class.name -> class. The whole list of found types that were used in class or interface for that
     * this implementor generated implementation. Saves only that types which {@link Class#getSimpleName()}
     * is different. For example:
     * <ul>
     *     <li>{@code java.util.List}</li>
     *     <li>{@code java.awt.List}</li>
     * </ul>
     * For these two only one will be saved into the map. In order that it could be used by its simple name in
     * generated code, while the other one will always be generated by its full name.
     */
    private final Map<String, Class<?>> imports;

    /**
     * Map of all generics in all class's hierarchy: raw type ->
     * actual (declared in child's inheritance) type
     *
     * @see TypeVariable
     * @see Type
     */
    private final Map<TypeVariable<?>, Type> generics;

    /**
     * Default constructor for Implementor class
     */
    public Implementor() {
        this.imports = new HashMap<>();
        this.generics = new HashMap<>();
    }

    /**
     * Method that allows you to run this code as a self-sufficient program
     *
     * @param args an array of arguments that indicates how do want to generate:
     *             <ul>
     *                  <li>parameters (keys)</li>
     *                  <li>class name</li>
     *                  <li>path to directory to generate in</li>
     *             </ul>
     *             There are two variants for arguments:
     *             <code>&lt;class-name&gt; &lt;root&gt;</code><br>
     *             <code>-jar &lt;class-name&gt; &lt;jar-filename&gt;</code>
     */
    public static void main(final String[] args) {
        assert args != null;
        assert args.length == 2 || args.length == 3;
        assert Arrays.stream(args).noneMatch(arg -> arg == null || arg.isBlank());

        final var jar = args.length == 3;

        if (jar) {
            assert args[0].equals("-jar");
            assert args[2].endsWith(".jar");
        }

        final var clazzName = args[jar ? 1 : 0];
        final Path root = Paths.get(args[jar ? 2 : 1]);

        try {
            final var clazz = Class.forName(clazzName);

            final var instance = new Implementor();

            if (jar) {
                instance.implementJar(clazz, root);
            } else {
                instance.implement(clazz, root);
            }
        } catch (final ClassNotFoundException e) {
            System.err.println("Given class not found: " + e.getMessage());
        } catch (final ImplerException e) {
            System.err.println("Class can not be generated according to: " + e.getMessage());
        }
    }

    @Override
    public void implement(final Class<?> token, final Path root) throws ImplerException {
        if (root == null) {
            throw new ImplerException("Folder to create class in can not be null");
        }

        if (token.isPrimitive() ||
                token.isEnum() ||
                token.isArray() ||
                token == Enum.class ||
                Modifier.isFinal(token.getModifiers()) ||
                Modifier.isPrivate(token.getModifiers())) {
            throw new ImplerException("Invalid given type: " + token.getTypeName());
        }

        final var fullPath = getClassPath(token, root);

        try {
            Files.createDirectories(fullPath);
        } catch (final IOException e) {
            throw new ImplerException("Invalid directory to create class in", e);
        }

        final var newFile = Paths.get(fullPath.toString(), token.getSimpleName() + IMPLEMENTATION_SUFFIX + ".java");

        try (final var writer = new BufferedWriter(Files.newBufferedWriter(newFile, Charset.defaultCharset()))) {
            final String[] wholeClass = {
                    generatePackage(token),
                    generateImports(token),
                    generateHeader(token),
                    generateConstructors(token),
                    generateMethods(token),
                    generateEnding(token),
            };

            for (final var part : wholeClass) {
                writer.write(toUnicode(part));
                writer.newLine();
            }
        } catch (final IOException e) {
            throw new ImplerException("Unable to write code to given file", e);
        }
    }

    @Override
    public void implementJar(final Class<?> token, final Path jarFile) throws ImplerException {
        final Path root = jarFile.toAbsolutePath().getParent();
        final var tmp = root.getParent().resolve("tmp" + token.getSimpleName());

        implement(token, tmp);

        try {
            final var codeSource = token.getProtectionDomain().getCodeSource();
            compileFiles(Paths.get(getClassPath(token, tmp).toString(), token.getSimpleName() + IMPLEMENTATION_SUFFIX + ".java"),
                    codeSource == null ? null : Paths.get(codeSource.getLocation().toURI()), tmp);
        } catch (final URISyntaxException e) {
            throw new ImplerException("Can not get real location path of the source code", e);
        }
        createJar(tmp, token.getPackageName().replace(".", "/"), jarFile);

        try {
            Files.walkFileTree(tmp, new SimpleFileVisitor<>() {
                @Override
                public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {
                    Files.delete(file);
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {
                    Files.delete(dir);
                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (final IOException e) {
            // no access to delete temporary files
        }
    }

    /**
     * Escapes string. Convert given string to unicode characters
     *
     * @param str the string to escape its characters
     * @return escaped string
     */
    private static String toUnicode(final String str) {
        return str.chars().mapToObj(c -> c < 128 ? Character.toString(c) + "" : String.format("\\u%04x", c))
                .collect(Collectors.joining());
    }

    /**
     * Search for all used types in the file
     *
     * @param token type to be inherited
     */
    private void preprocessingTypes(final Class<?> token) {
        imports.clear();

        saveImport(token);
        saveImport(Override.class);
        saveImport(Generated.class);

        Stream.concat(Stream.iterate(token, c -> c != null && c != Object.class, (UnaryOperator<Class<?>>) Class::getSuperclass)
                                .flatMap(c -> Stream.concat(
                                        Arrays.stream(c.getDeclaredMethods()),
                                        Arrays.stream(c.getDeclaredConstructors()))),
                        Arrays.stream(token.getMethods()))
                .filter(e -> (e instanceof Constructor<?> && !Modifier.isPrivate(e.getModifiers())) ||
                        Modifier.isAbstract(e.getModifiers()))
                .forEach(e -> {
                    if (e instanceof final Method method) {
                        saveImport(method.getReturnType());
                    }
                    saveImports(e.getParameterTypes());
                    saveImports(e.getExceptionTypes());
                    saveImports(Arrays.stream(e.getAnnotations()).map(Annotation::annotationType).toArray(Class<?>[]::new));
                });
    }

    /**
     * Search for all generics in all class hierarchy. And fills the map ({@link #generics}) from {@link TypeVariable}
     * to {@link Type} (raw type to actual (declared in child's inheritance) type)
     *
     * @param token type to be inherited
     * @throws ImplerException if somehow two similar generic parameters were found or
     * there is an unequal number of raw and actual generic types
     *
     * @see #generics
     * @see TypeVariable
     * @see Type
     */
    private void preprocessingGenerics(final Class<?> token) throws ImplerException {
        generics.clear();

        final Queue<Class<?>> queue = new ArrayDeque<>(List.of(token));

        while (!queue.isEmpty()) {
            final var cur = queue.poll();

            final List<Type> genSuperclasses = new ArrayList<>(Arrays.asList(cur.getGenericInterfaces()));
            final List<Class<?>> superclasses = new ArrayList<>(Arrays.asList(cur.getInterfaces()));

            if (!cur.isInterface()) {
                genSuperclasses.add(cur.getGenericSuperclass());
                superclasses.add(cur.getSuperclass());
            }

            for (int i = 0; i < superclasses.size(); i++) {
                final var gs = genSuperclasses.get(i);
                final var s = superclasses.get(i);

                if (gs instanceof final ParameterizedType pType) {
                    final var actualTypes = pType.getActualTypeArguments();
                    final var rawTypes = s.getTypeParameters();

                    assert rawTypes.length == actualTypes.length;

                    for (int j = 0; j < rawTypes.length; j++) {
                        if (generics.put(rawTypes[j], actualTypes[j]) != null) {
                            throw new ImplerException("Expected to be the unique generic parameter");
                        }
                    }
                }
            }

            queue.addAll(Arrays.asList(cur.getInterfaces()));

            if (cur.getSuperclass() != null) {
                queue.add(cur.getSuperclass());
            }
        }
    }

    /**
     * Finds path that is resolved from the root to the token's package
     *
     * @param token type to be inherited
     * @param root root directory
     * @return scaled path of the root
     */
    private static Path getClassPath(final Class<?> token, final Path root) {
        return root.resolve(Paths.get(token.getPackageName().replace('.', File.separatorChar)));
    }

    /**
     * Compile {@code file} to {@code out} directory using {@code sourceFiles}
     *
     * @param file file to compile
     * @param sourceFiles source code that is used for compiling
     * @param out directory to put binaries in
     */
    private static void compileFiles(final Path file, final Path sourceFiles, final Path out) {
        final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();

        assert compiler != null;

        try {
            Files.createDirectory(out);
        } catch (final IOException ignored) {
            // do nothing
        }

        final var args = new ArrayList<>(List.of(
                file.toString(),
                "-Xlint:deprecation",
                "-Xlint:unchecked",
                "-encoding", "utf8",
                "-d", out.toString()));
        if (sourceFiles != null) {
            args.add("-cp");
            args.add(sourceFiles.toString());
        }

        final int exitCode = compiler.run(null, null, null, args.toArray(String[]::new));

        assert exitCode == 0;
    }

    /**
     * Creates jar with files from {@code out}
     *
     * @param out directory with binaries
     * @param pckg package to put binaries in
     * @param jarFile name of the jar-file to create
     * @throws ImplerException if something happened while writing in created jar-file
     */
    private static void createJar(final Path out, final String pckg, final Path jarFile) throws ImplerException {
        final var manifest = new Manifest();
        final var attributes = manifest.getMainAttributes();
        attributes.put(Attributes.Name.MANIFEST_VERSION, "1.0");
        attributes.put(Attributes.Name.IMPLEMENTATION_VENDOR, PROJECT_NAME);

        try (final var jarOutputStream = new JarOutputStream(Files.newOutputStream(jarFile), manifest)) {
            for (final var clazz : Files.list(out.resolve(pckg)).toList()) {
                if (!clazz.toString().endsWith(".class")) {
                    continue;
                }

                jarOutputStream.putNextEntry(new ZipEntry(pckg + "/" + clazz.getFileName()));
                Files.copy(clazz, jarOutputStream);
            }
        } catch (final IOException e) {
            throw new ImplerException("Can not write to jar-file", e);
        }
    }

    /**
     * Generates package that is similar to the class's that it should inherit
     *
     * @param token type to be inherited
     * @return string with generated package. If there is no package method returns empty string
     */
    private static String generatePackage(final Class<?> token) {
        return token.getPackageName().isBlank() ? "" : PACKAGE + SPACE + token.getPackageName() + LINE_END;
    }

    /**
     * Generates list of imports of types which are used in the generated class. All types,
     * that were used in generated class, were put in the {@link #imports} map. This method
     * search through it and generate for each string like "{@code import &lt;lib&gt;;}".
     *
     * @param token type to be inherited
     * @return string containing all concatenated imports for libs in {@link #imports}
     *
     * @see #imports
     * @see #preprocessingTypes(Class)
     */
    private String generateImports(final Class<?> token) {
        preprocessingTypes(token);

        return join(imports.values().stream()
                .distinct()
                .filter(lib -> !lib.getPackageName().equals(""))
                .map(lib -> IMPORT + SPACE + lib.getCanonicalName() + LINE_END), "");
    }

    /**
     * <p>
     *     Generates header for class like
     * </p>
     *
     * <code>public class TestClassImpl extends TestClass</code>
     *
     * <p>
     *     Generates implementation-class header that extends or implements (weather token is class or
     *     interface) the given ({@code token}) one.
     * </p>
     *
     * <p>
     *     If parent class is parametrized with generics, then the implementation would also be
     *     parametrized. And its parameter's bounds will be the same.
     * </p>
     *
     * <code>
     *     public class Parent&lt;E extends Number&gt;
     *     <br>
     *     public class Child&lt;E extends Number&gt; extends Parent&lt;E&gt;
     * </code>
     *
     * @param token type to be inherited
     * @return string with generated package. If there is no package return empty string
     * @throws ImplerException if {@link #preprocessingGenerics(Class)} throws an exception
     */
    private String generateHeader(final Class<?> token) throws ImplerException {
        saveImport(token);

        preprocessingGenerics(token);

        final var generics = getGenerics(token.getTypeParameters());

        final var pre = "public class " + token.getSimpleName() + IMPLEMENTATION_SUFFIX;
        final var parent = (token.isInterface() ? IMPLEMENTS : EXTENDS) + SPACE + token.getSimpleName();

        if (generics.isEmpty()) {
            return "%s %s {".formatted(pre, parent);
        } else {
            return String.format("%s<%s> %s<%s> {",
                    pre, generics, parent,
                    String.join(PARAMETER_SEPARATOR, Arrays.stream(token.getTypeParameters())
                            .map(Type::getTypeName).toList()));
        }
    }

    /**
     * Generates implementation for all not-private constructors
     *
     * @param token parent
     * @return string containing all implementations as one large token
     * @throws ImplerException if there is no available constructor to refer to. For example, if parent class has the
     * only default constructor, and it is marked as {@code private}. So, child-class can not use {@code super(args...)}
     * to refer to any parents constructors.
     */
    private String generateConstructors(final Class<?> token) throws ImplerException {
        final var res = new StringBuilder();

        var defaultAvailable = true;
        for (final var constructor : token.getDeclaredConstructors()) {
            if (Modifier.isPrivate(constructor.getModifiers())) {
                if (constructor.getParameters().length == 0) {
                    defaultAvailable = false;
                }

                continue;
            }

            res.append(generateExecutable(constructor, "",
                    token.getSimpleName() + IMPLEMENTATION_SUFFIX, SUPER,
                    "(" + join(Arrays.stream(constructor.getParameters())
                            .map(Parameter::getName), PARAMETER_SEPARATOR) + ")"));
        }

        if (!defaultAvailable && res.isEmpty()) {
            throw new ImplerException("No default constructor is available and there is no constructor to inherit");
        }

        return res.toString();
    }

    /**
     * Generates implementation for all non-private and non-final methods
     *
     * @param token parent
     * @return string containing all implementations as one large token
     */
    private String generateMethods(final Class<?> token) {
        final var res = new StringBuilder();

        final var methods = Stream.concat(
                        Stream.<Class<?>>iterate(token, c -> c != null && c != Object.class, Class::getSuperclass)
                                .flatMap(c -> Arrays.stream(c.getDeclaredMethods())),
                        Arrays.stream(token.getMethods())
                )
                .map(MethodDescription::new)
                .collect(Collectors.toMap(MethodDescription::hashCode, MethodDescription::method, (m, m2) -> m))
                .values().stream();

        Stream.concat(methods, Arrays.stream(token.getDeclaredMethods())).distinct().filter(method -> {
                    final var modifiers = method.getModifiers();
                    return !Modifier.isPrivate(modifiers) &&
                            Modifier.isAbstract(modifiers) &&
                            !Modifier.isFinal(modifiers);
                })
                .map(MethodDescription::new)
                .distinct()
                .map(MethodDescription::method)
                .forEach(method -> res.append(generateExecutable(method, "@Override",
                            getTypeName(method.getGenericReturnType()) + SPACE + method.getName(), RETURN,
                            SPACE + DefaultValues.getDefaultByType(method.getReturnType()))).append(NEW_LINE));

        return res.toString();
    }

    /**
     * Generates class ending: "}" and a line break after
     *
     * @param token type to be inherited
     * @return String of class closing bracket
     */
    private String generateEnding(@SuppressWarnings("unused") final Class<?> token) {
        return "}" + NEW_LINE;
    }

    /**
     * Generates code for {@link Executable} with given parts (ex. {@code before, body, ...})
     *
     * @param executable class part to generate code for
     * @param before code to put before generated executable. For example: {@link  Annotation}s
     * @param name of the generated executable
     * @param keyWord {@code super} or {@code return}
     * @param body code for body of the executable
     * @param <T> type that inherits {@link Executable}
     * @return generated code
     *
     * @see Executable
     * @see Annotation
     */
    private <T extends Executable> StringBuilder generateExecutable(final T executable,
                                                                    final String before,
                                                                    final String name,
                                                                    final String keyWord,
                                                                    final String body) {
        final var res = new StringBuilder();

        final var exceptions = executable.getGenericExceptionTypes();

        tab(res, 1).append(before).append(NEW_LINE);

        tab(res, 1).append("@Generated(value = \"").append(PROJECT_NAME).append("\", date = \"").append(date).append("\")").append(NEW_LINE);
        Arrays.stream(executable.getAnnotations())
                .map(Annotation::annotationType)
                .map(this::getTypeName)
                .forEach(ant -> tab(res, 1).append("@").append(ant).append(NEW_LINE));

        final var modifiers = Modifier.toString(executable.getModifiers() & ~Modifier.NATIVE & ~Modifier.ABSTRACT & ~Modifier.TRANSIENT);

        tab(res, 1);
        if (!modifiers.isBlank()) {
            res.append(modifiers).append(SPACE);
        }

        final var generics = getGenerics(executable.getTypeParameters());

        if (!generics.isEmpty()) {
            res.append("<").append(generics).append(">").append(SPACE);
        }

        res.append(name).append("(");

        res.append(join(Arrays.stream(executable.getParameters())
                        .map(param -> getTypeName(param.getParameterizedType()) + SPACE + param.getName()),
                PARAMETER_SEPARATOR));

        res.append(")").append(SPACE);

        if (exceptions.length != 0) {
            res.append(THROWS).append(" ").append(
                    join(Arrays.stream(exceptions).map(this::getTypeName),
                            PARAMETER_SEPARATOR)).append(" ");
        }

        nl(res.append("{"));

        tab(res, 2).append(keyWord).append(body).append(EXPR_END);

        nl(tab(nl(res), 1).append("}"));

        return res;
    }

    /**
     * Get name for the given type. This method do a bit different things for different input types:
     *
     * <ul>
     *     <li>{@link Class} - checks in imports map, then choose between {@link Class#getSimpleName()} and
     *     {@link Class#getCanonicalName()}</li>
     *     <li>{@link WildcardType} - just {@link Type#getTypeName()}</li>
     *     <li>{@link TypeVariable} - searches through {@link #generics} map to get the full wrapper over
     *     the given type</li>
     *     <li>{@link GenericArrayType} - recursive call for {@link GenericArrayType#getGenericComponentType()}
     *     plus {@code []}</li>
     *     <li>{@link ParameterizedType} - get bounds for type anf generates result like this: "{@code &lt;T
     *     extends AClass & BClass, E&gt;}"</li>
     * </ul>
     * @param type class to retrieve name from
     * @return generated name for given type
     *
     * @see Type
     * @see Class
     * @see WildcardType
     * @see TypeVariable
     * @see GenericArrayType
     * @see ParameterizedType
     */
    private String getTypeName(final Type type) {
        if (type instanceof final Class<?> clazz) {
            if (clazz.isArray()) {
                return getTypeName(clazz.componentType()) + "[]";
            }

            final Class<?> savedType = imports.getOrDefault(clazz.getSimpleName(), null);

            return savedType != null && savedType == clazz ? clazz.getSimpleName() : clazz.getCanonicalName();
        } else if (type instanceof WildcardType) {
            return type.getTypeName();
        } else if (type instanceof TypeVariable<?>) {
            return generics.getOrDefault(type, null) != null ?
                    getTypeName(generics.get(type)) :
                    type.getTypeName();
        } else if (type instanceof final GenericArrayType genericArrayType) {
            return getTypeName(genericArrayType.getGenericComponentType()) + "[]";
        } else {
            final var pType = (ParameterizedType) type;
            final var args = join(Arrays.stream(pType.getActualTypeArguments()).map(this::getTypeName), PARAMETER_SEPARATOR);

            return getTypeName(pType.getRawType()) + "<" + args + ">";
        }
    }

    /**
     * Method to get all bounds of given types. For each given type it will find its bounds and join them to one string
     * separated by "{@code &}". After it concatenates all types to one string separated with commas.
     *
     * @param typeVariables array of generic variables
     * @return string of concatenated generic types with their bounds (separated by comma). If type's bound
     * is {@code Object.class}, it would return as if this type has no bounds.
     *
     * @see TypeVariable
     */
    private String getGenerics(final TypeVariable<?>[] typeVariables) {
        return join(Arrays.stream(typeVariables)
                        .map(t -> Map.entry(t.getName(), getBounds(t)))
                        .map(entry -> entry.getKey() + (!entry.getValue().isEmpty() ?
                                SPACE + EXTENDS + SPACE + String.join(SPACE + "&" + SPACE, entry.getValue()) : "")),
                PARAMETER_SEPARATOR);
    }

    /**
     * Gets a list of all the bounds for typeArgument. For example:
     *
     * <p>For {@code &lt;T&gt;} it will return:</p>
     * {@code emptyList}
     *
     * <p>For {@code &lt;T extends AType & BType&gt;} it will return:</p>
     * <ul>
     *     <li>{@code AType}</li>
     *     <li>{@code BType}</li>
     * </ul>
     *
     * @param typeVariable variable that could have bounds for it's type
     * @return list of bounds. It ignores {@code java.lang.Object} as a type's bound. So, for
     * {@code &lt;T extends Object&gt;} it will return {@code emptyList}
     */
    private List<String> getBounds(final TypeVariable<?> typeVariable) {
        return Arrays.stream(typeVariable.getBounds())
                .filter(b -> !b.equals(Object.class))
                .map(this::getTypeName).toList();
    }

    /**
     * Saves an array of types to {@link #imports} if {@code type.simpleName()} is absent as a key in the map
     *
     * @param typedArray an array of types to call {@link #saveImport(Class)} for each
     *
     * @see Class
     * @see #saveImport(Class)
     * @see Class#getSimpleName()
     */
    private void saveImports(final Class<?>... typedArray) {
        Arrays.stream(typedArray).forEach(this::saveImport);
    }

    /**
     * Saves a type to {@link #imports} if {@code type.simpleName()} is absent as a key in the map
     *
     * @param type a type to save its {@link Class#getSimpleName()} in the {@link #imports} if it is absent
     *             as a key
     *
     * @see Class
     * @see Class#getSimpleName()
     */
    private void saveImport(final Class<?> type) {
        if (type == null || type.isPrimitive()) {
            return;
        }

        if (type.isArray()) {
            saveImport(type.componentType());
        } else {
            imports.putIfAbsent(type.getSimpleName(), type);
        }
    }

    /**
     * Wrapper over {@link Method} to check equality by:
     * <ol>
     *     <li>name</li>
     *     <li>signature:
     *         <ul>
     *             <li>input parameter types</li>
     *             <li>return type</li>
     *         </ul>
     *     </li>
     * </ol>
     *
     * @see Method
     */
    private record MethodDescription(Method method) {

        @Override
        public boolean equals(final Object obj) {
            if (this == obj) {
                return true;
            }

            if (!(obj instanceof final MethodDescription other)) {
                return false;
            }

            return Objects.equals(method.getName(), other.method.getName()) &&
                    other.method.getReturnType().isAssignableFrom(method.getReturnType()) &&
                    Arrays.equals(method.getParameterTypes(), other.method.getParameterTypes());
        }

        @Override
        public int hashCode() {
            return method.getName().hashCode() + method.getReturnType().hashCode() + Arrays.hashCode(method.getParameterTypes());
        }
    }

    /**
     * Final class with some basic functionality and default values for generation
     */
    public static final class DefaultValues {

        /**
         * Space character
         */
        public static final String SPACE = " ";
        /**
         * Comma and space separator
         */
        public static final String PARAMETER_SEPARATOR = "," + SPACE;
        /**
         * Line separator
         */
        public static final String NEW_LINE = System.lineSeparator();
        /**
         * Tab character
         */
        public static final String TAB = "\t";
        /**
         * Semicolon character
         */
        public static final String EXPR_END = ";";
        /**
         * Semicolon and line break
         */
        public static final String LINE_END = EXPR_END + NEW_LINE;
        /**
         * Package keyword
         */
        public static final String PACKAGE = "package";
        /**
         * Import keyword
         */
        public static final String IMPORT = "import";
        /**
         * Extends keyword
         */
        public static final String EXTENDS = "extends";
        /**
         * Implements keyword
         */
        public static final String IMPLEMENTS = "implements";
        /**
         * Super keyword
         */
        public static final String SUPER = "super";
        /**
         * Return keyword
         */
        public static final String RETURN = "return";
        /**
         * Throws keyword
         */
        public static final String THROWS = "throws";

        /**
         * Gets a stringBuilder and adds a {@link #NEW_LINE} at it's end
         *
         * @param sb the stringBuilder to make changes with
         * @return given stringBuilder concatenated with {@link #NEW_LINE} at the end.
         *
         * @see StringBuilder
         */
        public static StringBuilder nl(final StringBuilder sb) {
            return sb.append(NEW_LINE);
        }

        /**
         * Gets a stringBuilder and adds several {@link #TAB} at it's end
         *
         * @param sb the stringBuilder to make changes with
         * @param lvl the number of tabs to add
         * @return given stringBuilder concatenated with &lt;{@code lvl}-count&gt; of {@link #TAB} at the end.
         *
         * @see StringBuilder
         */
        public static StringBuilder tab(final StringBuilder sb, final int lvl) {
            return sb.append(TAB.repeat(lvl));
        }

        /**
         * Gets a stream of strings joins them all to one string separated with {@code sep}
         *
         * @param stream sequence of strings to manipulate with
         * @param sep separator that will be put between each to strings in the given sequence
         * @return concatenated stream of strings that are separated with {@code sep}
         *
         * @see Stream
         */
        public static String join(final Stream<String> stream, final String sep) {
            return stream.collect(Collectors.joining(sep));
        }

        /**
         * Default values for some basic types to be generated
         */
        public static final Map<Class<?>, String> classToDefaultValue = Map.of(
                boolean.class,  "true",
                byte.class,     "0b0",
                char.class,     "'0'",
                short.class,    "0",
                int.class,      "0",
                long.class,     "0L",
                float.class,    "0f",
                double.class,   "0d",
                String.class,   "\"\"",
                Object.class,   "null"
        );

        /**
         * The method to get default value (for generation) by type
         *
         * @param type type to search in the map {@link #classToDefaultValue}
         * @return default value for given type
         *
         * @see Class
         */
        public static String getDefaultByType(final Class<?> type) {
            if (type == void.class) {
                return "";
            }

            if (type.isArray()) {
                return null;
            }

            return classToDefaultValue.getOrDefault(type, "null");
        }
    }
}
